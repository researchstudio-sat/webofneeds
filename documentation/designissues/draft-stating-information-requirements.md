# Stating Information Requirements

This document describes a possible approach for how owners can request information from their counterparts.

The basic idea is that an owner uses SHACL shapes to specify their information atoms. The counterpart then adds data to their communication channel (the connection) or invalidates already added data until the valid data in the channel can be validated by the shape. Information requirements are thought to be used to collect information without neccessarily immediate action to follow. If information is required to execute an action afterwards these should be described with [goals](goals.md). 

## Variants
Shapes can be used in atoms in the following ways:
1. /pre-matching/ - as part of the atom description
1. /post-matching/, i.e. during a conversation 
### pre-matching 
1. To specify matching constraints.  This is the case if 
    1. The shape is attached to a `won:seeks` node of the atom
    1. The shape specifies the `sh:severity` `sh:Violation` 
    1. such shapes should cause non-matching atoms to be filtered out while matching
1. To specify preferences. This is the case if
    1. The shape is attached to a `won:seeks` node of the atom
    1. The shape specifies the `sh:severity` `sh:Warning` 
    1. such shapes should cause a penalty for matched atoms that do not conform to the shape
1. To specify properties of interest. This is the case if
    1. The shape is attached to a `won:seeks` node of the atom
    1. The shape specifies the `sh:severity` `sh:Info` 
    1. such shapes should cause a boost for matched atoms that specify the property
    
### post-matching
In this case, the shape is embedded in the content of a message.
1. To specify properties of interest after matching. This is the case if  
    1. The shape is embedded in the content of a message via ´[atomuri]/won:seeks´ 
    1. The `sh:severity` is to be interpreted as an indication of urgency/importance or precedence if multiple shapes are present

This document is based on the [SHACL Constraint Language (SHACL) W3C Candidate Recommendation](https://www.w3.org/TR/shacl/)

## Evaluating information requirements
### constructing the shapes graph and the data graph
SHACL specifies how a [data graph](https://www.w3.org/TR/shacl/#data-graph) is validated against a [shapes graph](https://www.w3.org/TR/shacl/#shapes-graph).

In order to validate information requirements, we need to define how the shapes graph and the data graph are to be constructed from the available data:

At any point in time during a conversation between two atoms (referred to here as the atom and the counterpart), the available data consists of all data crawlable starting from the atom and starting from the counterpart. (including atom content graphs, atom sysinfo graph, atom's event container, connection container, connections, connection to counterpart including additional data (like feedback), connection's event container, the atom's messages and their remoteMessages, the counterpart's messages and their remoteMessages).

For validating the atom's information requirements:
* data graph: Compute the union of all triples in the available data that were generated by the counterpart: the counterpart itself (all graphs), as well as all messages that has its connection as the object of the `msg:sender` property, fetched from the atom's WoN node (i.e. the remoteMessages of the messages produced by the counterpart)
* shapes graph: Compute the union of all graphs in the atoms `won:seeks`branches that are referenced by `[Atom] won:shapesGraph [Graph]`

For validating the counterpart's information requirements:
* data graph: Compute the union of all triples in the available data that were generated by the atom: the atom itself (all graphs), as well as all messages that has its connection as the object of the `msg:sender` property, fetched from the atom's WoN node (i.e. the originals of the messages produced by the atom)
* shapes graph: Compute the union of all graphs in the counterparts `won:seeks`branches that are referenced by `[Counterpart] won:shapesGraph [Graph]`

This way, both sides can evaluate each other's information requirements and generate a GUI (e.g. a form, a map, or a calendar) for the user to enter the data.

For example one atom could specify that it searches for apartments for rent in Vienna. Aditionally to that it could express an information requirement that specifies the question if the apartment is first occupancy. The person would maybe in both cases rent the apartment but is willing to pay another price for a first occupancy apartment. The corresponding atom could look like this:

````
GRAPH :atomGraph {
  atom:apartmentForRentDemandAtom
  a won:Atom;
  won:seeks [
    dc:title "Looking for an apartment for rent in Vienna" ;
    won:location [
      a  s:Place ;
      s:name  "Wien, Österreich"
    ] ;
    
    won:shapesGraph :infoApartmentGrah ;
  ] ;
}

GRAPH :infoApartmentGrah {
  :apartment-shape
  a sh:NodeShape ;
  sh:label "Is the apartment first occupancy?" ;
  sh:message "The first occupancy information could not be found!" ;
  sh:targetClass rent:apartment ; 
  sh:severity sh:Info ;
  sh:property [
    sh:path ( rent:isFirstOccupancy ) ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
    sh:datatype xsd:boolean 
  ] ;
}
````

After the atom got matched with a counterpart atom that could offer an apartment for rent it could open a connection to start a conversation. Depending on the features and ontology knowledge of the counterpart atom there could be two situations. 

First the counterpart (apartment offer atom) evaluates the information requirement shape graph `:infoApartmentGrah` on its on data and realises that the first occupancy information is still missing and that the `atom:apartmentForRentDemandAtom` would like to know about it. If the owner GUI of the apartment offer atom has some flexible feature to show gui elements dynamically it could show a checkbox to the end user with the question from the shape graph label `"Is the apartment first occupancy?"` to ask for the information. The information could then be sent in a message of the conversation and would then satisfy the `:infoApartmentGrah`:

````
event:event1 won:contentGraph :apartment-solution .

GRAPH :apartment-solution {
    atom:atomApartmentOffer a rent:apartment ;
    isFirstOccupancy false
}
````

Second if the counterpart atom doesn't evaluate the `:infoApartmentGrah` on its own the `atom:apartmentForRentDemandAtom` could explicitely ask for the information about first occupancy automatically (e.g. using a bot) using text messages. For instance `:infoApartmentGrah` would first evaluate unsuccessfully with severity `sh:Info`. Then the result message `"Is the apartment first occupancy?"` could be used to sent to the counterpart atom with waiting for an yes/no answer. However this second scenario is more unlikely than the first one since some natural language processing would be needed to interpret the possible answer(s) to the question asked.  

## Changes required in current system; design issues

1. Importing atoms must be changed to allow for importing datasets (otherwise, we are not able to specify shapes graphs). This would also be required to specify multiple datasets with different access control settings, so this change might be useful for the future.
1. In the case of the factory bot, these atoms are factory atoms. The bot must be aware of the shape graphs and copy them to the concrete offers.
1. The shapes atom to be validated by the bot when it is acting as a bridge to a Web API.
1. The shapes atom to be interpreted and validated by the owner application - so it can generate GUI elements asking for values.
    1. investigate further, starting [here](https://lists.w3.org/Archives/Public/public-rdf-shapes/2014Aug/0094.html)
    1. started a [thread in the mailing list](https://lists.w3.org/Archives/Public/public-rdf-shapes/2017May/0039.html)
    1. we'll see
    1. Then again, there is [ShEx](http://shex.io/shex-semantics/index.html) - seems pretty straightforward
1. GUI generation in the owner application will not be available for a long time. So *what can we do instead?*
    1. We actually don' know what the counterpart does with the SHACL shapes it finds in our bot's atom. Maybe it has some advanced algorithms evaluating them and then providing more triples, maybe not. We have to wait for messages that improve our validation result.
    1. Such messages would have to contain triples in their content graphs that our shapes are expecting.
        1. simplest solution is to add an imput field for raw RDF data in the owner app.
    1. Alternatively, the counterpart could send messages that tell us to ignore certain graphs that have been sent earlier, because they contained wrong data, or data that is no longer true (such as the current location). The semantics would be 'Graph XY (the one to ignore) is false'.
        1. We have defined how messages can later be retracted in [our DeSemWeb2017 publication](http://ceur-ws.org/Vol-1934/contribution-07.pdf) - we just atom to implement that and give it a good GUI
    1. How could the bot could encourage such messages?
        1. Variant A: Keep it simple - show results - wait for triples
            1. validate the current data with the shapes
            1. send the validation result to the counterpart
            1. wait for triples that improve the result or messages that invalidate certain graphs (and thereby improve the result).
        1. Variant B: Question - Suggestion - Question loop (technically more complicated)
            1. validate the current data with the shapes
            1. create plaintext questions based on the validation result
            1. ask the counterpart those questions
            1. The counterpart answers in plain text (i.e. messages with msg:textMessage triples).
            1. The bot generates RDF triples from the response, adds them to the data graph and validates again. If the validation result has improved (fewer problems), the new triples are assumed to be correct. Now they somehow have to be added to the data accepted/asserted by the counterpart.
            1. The bot sends a message to the counterpart that contains the new triples in its content graph. The semantics of the message is a 'suggestion': The bot asks the counterpart to accept these triples as true. The triples are displayed to the counterpart user and she can accept/deny the triples (as a toggle button next to the displayed triples)
            1. In cases of missing triples where default values are present in the SHACL, the bot can suggest the triples using the default values, without even asking a question.
            1. If the user accepts the triples as correct, the counterpart sends a message with the semantics 'Graph XY (the one the bot sent) is true'
        
